---
# 这是文章的标题
title: Redis基础
# 这是页面的图标
icon: file
# 这是侧边栏的顺序
order: 1
# 设置作者
author: Xmerge
# 设置写作时间
date: 2024-01-04
# 一个页面可以有多个分类
category:
  - 八股
  - 数据库
  - Redis
# 一个页面可以有多个标签
tag:
  - 八股
  - 数据库
  - Redis
# 此页面会在文章列表置顶
sticky: true
# 此页面会出现在文章收藏中
star: true
---

Redis面试题汇总（基础篇）

<!-- more -->

### 1. Redis基础数据结构

**问：Redis有哪些基础数据结构？**
答：Redis共有5种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。

**问：说明一下每个数据结构，并且给我列举几个每种数据结构的应用场景？**
答：常用场景可见下表：

| **数据结构** | String | List   | Set    | Hash   | Zset  |
|----------|--------|--------|--------|--------|----------|
| **描述** | 字符串 | 列表   | 集合   | 散列   | 有序集合   |
| **说明** | 一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。 | Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。   | 无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。   | 一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。   | 和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。   |
| **常用场景** | 缓存、Token、地址、序列化后的对象 | 最新文章、动态   | 不能重复的数据（如点赞统计）、需要计算数据交集或并集的场景   | 用户信息、商品信息、文章信息等   | 排行榜   |


### 2. Redis持久化

**问：Redis持久化有哪些方式？**
答：Redis支持3种持久化方式，分别是快照（<font color="#304FFE">**RDB**</font>, snapshotting）、只追加文件（<font color="#304FFE">**AOF**</font>, apend-only file）、RDB与AOF混合（Redis4.0后新增）。

**问：光这样说我听不懂啊，RDB和AOF分别是什么意思？**
答：先介绍RDB持久化吧，Redis 可以通过<font color="#304FFE">**创建快照**</font>来获得存储在内存里面的数据在**某个时间点**上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用，快照持久化是 Redis 默认采用的持久化方式。

**问：RDB创建快照时会阻塞主线程吗？**
答：Redis默认采用`bgsave`，会fork出一个子进程，不会影响主进程（主线程），如果使用`save`命令，则会阻塞主进程。

**问：明白了，再介绍一下AOF持久化吧？**
答：AOF是指将**写操作**保存到日志种的持久化方式（不用保存读操作，因为对数据没有影响），如果Redis服务器宕机重启了，读取AOF日志即可重新获得保存AOF文件时的Redis数据。

**问：AOF文件的写入时机了解吗？**
答：Redis保存AOF文件时和MySQL策略不同，Redis是先执行写操作命令，然后才将该记录写入AOF日志。
答：这样做会带来两个好处：其一，<font color="#304FFE">**避免额外的检查开销**</font>（写操作成功执行则说明这个操作是没有语法等问题的，如果先写入AOF的话需要额外进行检查）；其二，<font color="#304FFE">**不会阻塞当前写操作命令执行**</font>（因为已经写入完成后才进行AOF写入）。

**问：那这个策略会带来什么问题吗？**
答：当然有，上述两个好处也会带来两个相应风险：其一，<font color="#304FFE">**数据可能会丢失**</font>（如果某个写操作完成后，AOF还没来得及写入就宕机了，那么这个写操作的数据就丢失了）；其二，<font color="#304FFE">**可能阻塞下一条命令**</font>（因为写入AOF的操作是在主进程同步完成的）。

**问：我注意到你说RDB会fork一个子进程，而AOF会阻塞主进程？**
答：实际上，AOF一般也不会造成阻塞，虽然AOF持久化是顺序执行的，但是Redis使用了操作系统的异步写入机制，但在数据过于庞大的情况下，仍有可能阻塞主进程。

**问：很好，我还对这个AOF感兴趣，再讲讲？**
答：造成上述AOF问题的原因，其实都跟**AOF日志写回时机**有关。Redis写入AOF时，提供了3种写回策略：
- `Always`，每次写操作执行完后，都同步将AOF日志写回到硬盘；
- `Everysec`，每次写操作执行完后，先讲命令写入AOF文件的内核缓冲区，然后每秒执行一次AOF文件写回；
- `No`，不由Redis控制写回时机，由操作系统控制写回。
每种策略的优略也很明显了，`Always`可靠性最高，但性能开销最大，而`No`的可靠性最低，但是性能最好；`Everysec`相对折中。

**问：这个AOF文件不会越来越大吗？**
答：聪明如你，AOF日志其实就是个文本文件，随着写操作命令增多，AOF文件也会变大。如果AOF文件过大，Redis服务重启后就会花费大量时间来读取AOF文件，造成时间损耗。
答：Redis为了避免AOF文件过大，提供了<font color="#304FFE">**AOF重写机制**</font>，定期重写AOF来实现文件压缩。
答：重写的机制在于，如果某个键的值被多次修改，重写时只会记录最后一次修改的值（之前的修改直接舍弃），从而实现文件压缩。

**问：明白了，那这个AOF重写是不是也跟AOF写入一样，是在主进程完成呢？**
答：好问题，AOF日志的写入是在主进程执行的，因为他每次写入内容不多，一般不会太影响，但是AOF重写时，需要读写大量操作，所以是在后台**子进程**（注意是子进程，不是子线程）执行的。
答：这样带来两个好处：不影响主进程执行、子进程会自动创建数据副本。

**问：你刚刚让我注意AOF重写时子进程和子线程的区别，什么意思？**
答：下回分解